/*
 * generated by Xtext 2.12.0
 */
package org.xtext.example.mydsl.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.xtext.example.mydsl.services.VideoGenGrammarAccess;
import org.xtext.example.mydsl.videoGen.AlternativesMedia;
import org.xtext.example.mydsl.videoGen.BlackWhiteFilter;
import org.xtext.example.mydsl.videoGen.FlipFilter;
import org.xtext.example.mydsl.videoGen.ImageDescription;
import org.xtext.example.mydsl.videoGen.MandatoryMedia;
import org.xtext.example.mydsl.videoGen.NegateFilter;
import org.xtext.example.mydsl.videoGen.OptionalMedia;
import org.xtext.example.mydsl.videoGen.VideoDescription;
import org.xtext.example.mydsl.videoGen.VideoGenInformation;
import org.xtext.example.mydsl.videoGen.VideoGenPackage;
import org.xtext.example.mydsl.videoGen.VideoGeneratorModel;
import org.xtext.example.mydsl.videoGen.VideoText;

@SuppressWarnings("all")
public class VideoGenSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private VideoGenGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == VideoGenPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case VideoGenPackage.ALTERNATIVES_MEDIA:
				sequence_AlternativesMedia(context, (AlternativesMedia) semanticObject); 
				return; 
			case VideoGenPackage.BLACK_WHITE_FILTER:
				sequence_BlackWhiteFilter(context, (BlackWhiteFilter) semanticObject); 
				return; 
			case VideoGenPackage.FLIP_FILTER:
				sequence_FlipFilter(context, (FlipFilter) semanticObject); 
				return; 
			case VideoGenPackage.IMAGE_DESCRIPTION:
				sequence_ImageDescription(context, (ImageDescription) semanticObject); 
				return; 
			case VideoGenPackage.MANDATORY_MEDIA:
				sequence_MandatoryMedia(context, (MandatoryMedia) semanticObject); 
				return; 
			case VideoGenPackage.NEGATE_FILTER:
				sequence_NegateFilter(context, (NegateFilter) semanticObject); 
				return; 
			case VideoGenPackage.OPTIONAL_MEDIA:
				sequence_OptionalMedia(context, (OptionalMedia) semanticObject); 
				return; 
			case VideoGenPackage.VIDEO_DESCRIPTION:
				sequence_VideoDescription(context, (VideoDescription) semanticObject); 
				return; 
			case VideoGenPackage.VIDEO_GEN_INFORMATION:
				sequence_VideoGenInformation(context, (VideoGenInformation) semanticObject); 
				return; 
			case VideoGenPackage.VIDEO_GENERATOR_MODEL:
				sequence_VideoGeneratorModel(context, (VideoGeneratorModel) semanticObject); 
				return; 
			case VideoGenPackage.VIDEO_TEXT:
				sequence_VideoText(context, (VideoText) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Media returns AlternativesMedia
	 *     AlternativesMedia returns AlternativesMedia
	 *
	 * Constraint:
	 *     (id=ID? medias+=MediaDescription+)
	 */
	protected void sequence_AlternativesMedia(ISerializationContext context, AlternativesMedia semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns BlackWhiteFilter
	 *     BlackWhiteFilter returns BlackWhiteFilter
	 *
	 * Constraint:
	 *     {BlackWhiteFilter}
	 */
	protected void sequence_BlackWhiteFilter(ISerializationContext context, BlackWhiteFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns FlipFilter
	 *     FlipFilter returns FlipFilter
	 *
	 * Constraint:
	 *     (orientation='h' | orientation='horizontal' | orientation='v' | orientation='vertical')
	 */
	protected void sequence_FlipFilter(ISerializationContext context, FlipFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MediaDescription returns ImageDescription
	 *     ImageDescription returns ImageDescription
	 *
	 * Constraint:
	 *     (imageid=ID? location=STRING (top=STRING bottom=STRING)?)
	 */
	protected void sequence_ImageDescription(ISerializationContext context, ImageDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Media returns MandatoryMedia
	 *     MandatoryMedia returns MandatoryMedia
	 *
	 * Constraint:
	 *     description=MediaDescription
	 */
	protected void sequence_MandatoryMedia(ISerializationContext context, MandatoryMedia semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VideoGenPackage.Literals.MANDATORY_MEDIA__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VideoGenPackage.Literals.MANDATORY_MEDIA__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMandatoryMediaAccess().getDescriptionMediaDescriptionParserRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Filter returns NegateFilter
	 *     NegateFilter returns NegateFilter
	 *
	 * Constraint:
	 *     {NegateFilter}
	 */
	protected void sequence_NegateFilter(ISerializationContext context, NegateFilter semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Media returns OptionalMedia
	 *     OptionalMedia returns OptionalMedia
	 *
	 * Constraint:
	 *     description=MediaDescription
	 */
	protected void sequence_OptionalMedia(ISerializationContext context, OptionalMedia semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, VideoGenPackage.Literals.OPTIONAL_MEDIA__DESCRIPTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, VideoGenPackage.Literals.OPTIONAL_MEDIA__DESCRIPTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOptionalMediaAccess().getDescriptionMediaDescriptionParserRuleCall_1_0(), semanticObject.getDescription());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     MediaDescription returns VideoDescription
	 *     VideoDescription returns VideoDescription
	 *
	 * Constraint:
	 *     (
	 *         videoid=ID? 
	 *         location=STRING 
	 *         duration=INT? 
	 *         probability=INT? 
	 *         description=STRING? 
	 *         filter=Filter? 
	 *         text=VideoText?
	 *     )
	 */
	protected void sequence_VideoDescription(ISerializationContext context, VideoDescription semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VideoGenInformation returns VideoGenInformation
	 *
	 * Constraint:
	 *     (authorName=STRING version=STRING? creationDate=STRING?)
	 */
	protected void sequence_VideoGenInformation(ISerializationContext context, VideoGenInformation semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VideoGeneratorModel returns VideoGeneratorModel
	 *
	 * Constraint:
	 *     (information=VideoGenInformation? medias+=Media+)
	 */
	protected void sequence_VideoGeneratorModel(ISerializationContext context, VideoGeneratorModel semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VideoText returns VideoText
	 *
	 * Constraint:
	 *     (content=STRING position=Position color=STRING? size=INT?)
	 */
	protected void sequence_VideoText(ISerializationContext context, VideoText semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
